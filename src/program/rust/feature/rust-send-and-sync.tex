\documentclass[../../../dolphin-book-2023.tex]{subfiles}

\begin{document}

\subsection{Rust的Send、Sync Trait}

Rust的野心是提高内存安全性、数据争用安全性（并发）和类型安全性。The stated ambition is improved memory safety, data-race safety (concurrency) and type safety. 而Send、Sync就是安全的保证并发的基础(Send and Sync are fundamental to Rust's concurrency story)。

Send意味着在单个其他线程上访问T是安全的，其中在执行时间线上每一个线程具有一次性的独占访问权。这种类型的值可以通过将独一无二的所有权转移到另一个线程，或者通过独一无二的借用(\&mut T)在另一个线程上使用。由于在每一个线程上访问T的值那一时刻具有独一无二的访问权，从而达到线程安全。此特征的更具描述性的名称可能是 UniqueThreadSafe 。

Sync意味着多个线程可同时访问T是安全的，每个线程都有共享访问权限。这些类型的值可以通过共享引用(\&T)在其他线程上访问<实际上是共享只读而不是写>。由于共享的是引用不是所有权和借用，共享的是只读，从而达到线程安全。更具描述性的名称是 SharedThreadSafe 。

简单的理解就是Send同时只属于一个线程，是独占的。Sync同一时刻可以在线程之间共享，但是是不可变的。那么既要可变，又要多线程共享，该如何实现呢？主要有2种类型来实现，Mutex<T>和RwLock<T>,它们提供了内部可变性,在内部实现中调用了操作系统的多线程同步机制,可以保证线程安全。C++、Java语言中实现线程安全，本质上是使用系统内核或线程库提供的安全PV互斥机制运行时来申请一块安全逻辑代码块，在这个逻辑代码块中可以由开发人员加上任意访问<读或写>对象的代码逻辑，进而实现线程安全访问。1965年，荷兰学者 Dijkstra 提出了一种卓有成效的实现进程同步和互斥的方法 — 信号量机制（Semaphore）。信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：1）P 操作：将信号量值减 1，表示申请占用一个资源。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。
可以这么理解，当信号量的值为 2 的时候，表示有 2 个资源可以使用，当信号量的值为 -2 的时候，表示有两个进程正在等待使用这个资源。不看这句话真的无法理解 V 操作，看完顿时如梦初醒。
2）V 操作：将信号量值加 1，表示释放一个资源，即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去。C++、Java实现的并发容易导致锁的代码块范围过大或其中的对象存在相互依赖导致的互锁等；而Rust提供了另一种细粒度<区分所有权、是否只读、只在指定类型对象指定代码块加锁>的解决方案，它充分利用了语言的静态检查能力，并只在最小的代码块中使用运行时的锁机制来保证线程安全；

\end{document}